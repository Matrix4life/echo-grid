<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>Echo Grid (Minimal)</title>
<style>
  :root{
    --bg1:#0b1020; --bg2:#111c33; --card:rgba(18,28,52,.72);
    --stroke:rgba(255,255,255,.12); --txt:#e8eefc; --muted:#97a7c6;
  }
  *{box-sizing:border-box;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  body{
    margin:0; min-height:100vh;
    background:radial-gradient(1200px 800px at 20% 10%, #172a55, #0b0f1a 55%);
    color:var(--txt);
    display:flex; align-items:center; justify-content:center;
    padding:14px;
  }
  .app{width:100%; max-width:560px;}
  .hud{
    display:flex; gap:10px; align-items:center; justify-content:space-between;
    margin-bottom:10px;
  }
  .pill{
    background:rgba(20,32,58,.55);
    border:1px solid var(--stroke);
    border-radius:999px;
    padding:8px 12px;
    font-weight:700;
    display:flex; gap:10px; align-items:center;
  }
  .pill span{color:var(--muted); font-weight:700}
  .boardCard, .piecesCard{
    background:linear-gradient(180deg, rgba(18,28,52,.80), rgba(10,14,26,.72));
    border:1px solid rgba(255,255,255,.10);
    border-radius:18px;
    box-shadow:0 10px 30px rgba(0,0,0,.35);
  }
  .boardCard{padding:12px;}
  canvas#c{
    display:block;
    width:min(94vw, 520px);
    height:min(94vw, 520px);
    max-width:520px; max-height:520px;
    border-radius:14px;
    background:linear-gradient(180deg, rgba(27,39,64,.65), rgba(12,18,34,.65));
    border:1px solid rgba(36,53,86,.80);
    touch-action:none;
    margin:0 auto;
  }
  .piecesCard{margin-top:10px; padding:10px;}
  .piecesRow{
    display:flex; gap:10px; justify-content:space-between;
  }
  .slot{
    flex:1;
    border-radius:14px;
    border:1px solid rgba(36,53,86,.80);
    background:rgba(27,39,64,.22);
    padding:8px;
    position:relative;
    min-width:0;
  }
  .slot.used{opacity:.35; filter:saturate(.6);}
  .slotLabel{
    margin-top:6px;
    font-size:12px;
    color:var(--muted);
    text-align:center;
    font-weight:800;
    letter-spacing:.2px;
  }
  .mini{
    width:100%; height:76px;
    border-radius:12px;
    display:block;
    background:rgba(27,39,64,.22);
  }
  #err{
    margin-top:10px;
    white-space:pre-wrap;
    color:#ffd0d0;
    background:rgba(120,20,20,.22);
    border:1px solid rgba(255,120,120,.25);
    padding:10px;
    border-radius:12px;
    display:none;
  }
</style>
<style>
/* --- Layout override: scores top, board center, blocks bottom --- */
body {
  flex-direction: column;
  justify-content: flex-start;
}
.app {
  width: 100%;
  max-width: 560px;
  display: flex;
  flex-direction: column;
  align-items: center;
}
.hud {
  width: 100%;
  justify-content: center !important;
  margin-top: 10px;
  margin-bottom: 14px;
}
.boardCard {
  width: 100%;
}
.piecesCard {
  width: 100%;
  margin-top: 16px !important;
}
.piecesRow {
  justify-content: center !important;
}
</style>
</head>
<body>
  <div class="app">
    <div class="hud">
      <div class="pill"><span>Score</span><b id="score">0</b></div>
      <div class="pill"><span>Top</span><b id="best">0</b></div>
    </div>

    <div id="banner" style="display:none;margin:10px 0;padding:10px 12px;border-radius:14px;
      background:rgba(20,32,58,.55);border:1px solid rgba(255,255,255,.12);width:100%;">
      <b id="bannerTitle">Game Over</b>
      <div id="bannerText" style="color:var(--muted);margin-top:4px;">No legal placements remain.</div>
      <button id="restartBtn" style="margin-top:10px;width:100%;padding:10px 12px;border-radius:12px;
        border:1px solid rgba(255,255,255,.12);background:rgba(27,39,64,.35);color:var(--txt);font-weight:800;cursor:pointer;">
        New Game
      </button>
    </div>

    <div class="boardCard">
      <canvas id="c" width="680" height="680"></canvas>
    </div>

    <div class="piecesCard">
      <div class="piecesRow" id="pieces"></div>
    </div>

    <div id="err"></div>
  </div>

<script>
(() => {
  const GRID=7, PAD=18, GAP=4;
  const canvas=document.getElementById("c");
  const ctx=canvas.getContext("2d");
  const errEl=document.getElementById("err");
  const scoreEl=document.getElementById("score");
  const bestEl=document.getElementById("best");
  const piecesEl=document.getElementById("pieces");

  // Special tiles
  const GRAY_START_USES = 4;
  const GRAY_COUNT = 6;
  const BLACK_TO_WALL_TURNS = 3;

  // Cell types:
  // null empty
  // {t:'c', color:'#hex'} colored
  // {t:'g', uses:n} gray countdown
  // {t:'b', ttl:n} black seed countdown -> wall
  // {t:'w'} wall
  const isEmpty=v=>v==null;
  const isGray=v=>v&&v.t==='g';
  const isBlack=v=>v&&v.t==='b';
  const isWall=v=>v&&v.t==='w';
  const isColor=v=>v&&v.t==='c';
  const isPlaceable=v=>isEmpty(v)||isGray(v);

  const COLORS=["#6ee7ff","#a78bfa","#fb7185","#34d399","#fbbf24","#60a5fa","#f472b6","#22c55e","#f97316"];
  const SHAPES=[
    [[1]], [[1,1]], [[1],[1]], [[1,1,1]], [[1],[1],[1]],
    [[1,1,1,1]], [[1],[1],[1],[1]], [[1,1],[1,1]],
    [[1,0],[1,0],[1,1]], [[0,1],[0,1],[1,1]],
    [[1,1,1],[0,1,0]], [[1,1,0],[0,1,1]], [[0,1,1],[1,1,0]],
    [[1,1,1],[1,0,0]], [[1,1,1],[0,0,1]],
  ];

  let board=null;
  let pieces=[];
  let score=0, best=0;

  // input
  let dragging=null; // {piece, idx, x,y}
  let hoverCell=null;

  function rr(c,x,y,w,h,r){
    r=Math.max(0, Math.min(r, Math.min(w,h)/2));
    c.beginPath();
    c.moveTo(x+r,y);
    c.arcTo(x+w,y,x+w,y+h,r);
    c.arcTo(x+w,y+h,x,y+h,r);
    c.arcTo(x,y+h,x,y,r);
    c.arcTo(x,y,x+w,y,r);
    c.closePath();
  }
  function hexToRgba(hex,a){
    const h=hex.replace("#","");
    const r=parseInt(h.slice(0,2),16), g=parseInt(h.slice(2,4),16), b=parseInt(h.slice(4,6),16);
    return `rgba(${r},${g},${b},${a})`;
  }

  function emptyBoard(){return Array.from({length:GRID},()=>Array(GRID).fill(null));}

  function cellSize(){const inner=canvas.width-PAD*2; return (inner-GAP*(GRID-1))/GRID;}
  function cellToPx(x,y){const s=cellSize(); return {px:PAD+x*(s+GAP), py:PAD+y*(s+GAP), s};}
  function getRect(){return canvas.getBoundingClientRect();}
  function clientToCanvas(clientX,clientY){
    const r=getRect(); const sx=canvas.width/r.width; const sy=canvas.height/r.height;
    return {x:(clientX-r.left)*sx, y:(clientY-r.top)*sy};
  }
  function pointerToGrid(clientX,clientY){
    const r=getRect(); const sx=canvas.width/r.width; const sy=canvas.height/r.height;
    const x=(clientX-r.left)*sx, y=(clientY-r.top)*sy;
    const s=cellSize();
    const gx=Math.floor((x-PAD+GAP/2)/(s+GAP));
    const gy=Math.floor((y-PAD+GAP/2)/(s+GAP));
    const inside=(x>=PAD && y>=PAD && x<=canvas.width-PAD && y<=canvas.height-PAD);
    if(!inside) return null;
    if(gx<0||gy<0||gx>=GRID||gy>=GRID) return null;
    return {x:gx,y:gy};
  }

  function newPiece(){
    const shape=SHAPES[Math.floor(Math.random()*SHAPES.length)];
    const color=COLORS[Math.floor(Math.random()*COLORS.length)];
    return {shape, h:shape.length, w:shape[0].length, color, used:false};
  }
  function rollPieces(){ pieces=[newPiece(),newPiece(),newPiece()]; renderPieces(); }

  function canPlace(p,gx,gy){
    for(let y=0;y<p.h;y++) for(let x=0;x<p.w;x++){
      if(!p.shape[y][x]) continue;
      const bx=gx+x, by=gy+y;
      if(bx<0||by<0||bx>=GRID||by>=GRID) return false;
      if(!isPlaceable(board[by][bx])) return false;
    }
    return true;
  }

  function placePiece(p,gx,gy){
    let effective=0;
    for(let y=0;y<p.h;y++) for(let x=0;x<p.w;x++){
      if(!p.shape[y][x]) continue;
      const bx=gx+x, by=gy+y;
      const cur=board[by][bx];
      if(isGray(cur)){
        const next=(cur.uses|0)-1;
        if(next>0) board[by][bx]={t:'g', uses: next};
        else board[by][bx]={t:'b', ttl: BLACK_TO_WALL_TURNS};
      } else {
        board[by][bx]={t:'c', color:p.color};
        effective++;
      }
    }
    return effective;
  }

  // pockets: empties NOT connected to edge (walls behave like edge)
  function pocketsOnBoard(b){
    const visited=Array.from({length:GRID},()=>Array(GRID).fill(false));
    const q=[];
    const dirs=[[1,0],[-1,0],[0,1],[0,-1]];

    for(let i=0;i<GRID;i++){
      if(isEmpty(b[0][i])){visited[0][i]=true;q.push([i,0]);}
      if(isEmpty(b[GRID-1][i])){visited[GRID-1][i]=true;q.push([i,GRID-1]);}
      if(isEmpty(b[i][0])){visited[i][0]=true;q.push([0,i]);}
      if(isEmpty(b[i][GRID-1])){visited[i][GRID-1]=true;q.push([GRID-1,i]);}
    }

    for(let y=0;y<GRID;y++) for(let x=0;x<GRID;x++){
      if(!isWall(b[y][x])) continue;
      for(const [dx,dy] of dirs){
        const nx=x+dx, ny=y+dy;
        if(nx<0||ny<0||nx>=GRID||ny>=GRID) continue;
        if(visited[ny][nx]) continue;
        if(!isEmpty(b[ny][nx])) continue;
        visited[ny][nx]=true; q.push([nx,ny]);
      }
    }

    while(q.length){
      const [x,y]=q.shift();
      for(const [dx,dy] of dirs){
        const nx=x+dx, ny=y+dy;
        if(nx<0||ny<0||nx>=GRID||ny>=GRID) continue;
        if(visited[ny][nx]) continue;
        if(!isEmpty(b[ny][nx])) continue;
        visited[ny][nx]=true; q.push([nx,ny]);
      }
    }

    const pockets=[];
    const seen=Array.from({length:GRID},()=>Array(GRID).fill(false));
    for(let y=0;y<GRID;y++) for(let x=0;x<GRID;x++){
      if(isEmpty(b[y][x]) && !visited[y][x] && !seen[y][x]){
        const stack=[[x,y]]; seen[y][x]=true;
        const cells=[];
        while(stack.length){
          const [cx,cy]=stack.pop();
          cells.push({x:cx,y:cy});
          for(const [dx,dy] of dirs){
            const nx=cx+dx, ny=cy+dy;
            if(nx<0||ny<0||nx>=GRID||ny>=GRID) continue;
            if(seen[ny][nx]) continue;
            if(!isEmpty(b[ny][nx])) continue;
            if(visited[ny][nx]) continue;
            seen[ny][nx]=true; stack.push([nx,ny]);
          }
        }
        pockets.push(cells);
      }
    }
    return pockets;
  }

  function tickBlackSeedsFlagged(){
    const pockets=pocketsOnBoard(board);
    if(!pockets.length) return 0;
    const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
    const targets=new Set();
    for(const pocket of pockets){
      for(const c of pocket){
        for(const [dx,dy] of dirs){
          const nx=c.x+dx, ny=c.y+dy;
          if(nx<0||ny<0||nx>=GRID||ny>=GRID) continue;
          if(isBlack(board[ny][nx])) targets.add(ny*GRID+nx);
        }
      }
    }
    let formed=0;
    for(const key of targets){
      const y=Math.floor(key/GRID), x=key%GRID;
      const v=board[y][x];
      if(!isBlack(v)) continue;
      const next=(v.ttl|0)-1;
      if(next>0) board[y][x]={t:'b', ttl: next};
      else { board[y][x]={t:'w'}; formed++; }
    }
    return formed;
  }

  function capture(){
    const pockets=pocketsOnBoard(board);
    if(!pockets.length) return {cleared:0, interior:0};
    const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
    const boundary=new Set();
    let interior=0;
    for(const pocket of pockets){
      interior += pocket.length;
      for(const cell of pocket){
        for(const [dx,dy] of dirs){
          const nx=cell.x+dx, ny=cell.y+dy;
          if(nx<0||ny<0||nx>=GRID||ny>=GRID) continue;
          if(board[ny][nx]!=null) boundary.add(ny*GRID+nx);
        }
      }
    }
    let cleared=0;
    for(const key of boundary){
      const y=Math.floor(key/GRID), x=key%GRID;
      if(isColor(board[y][x])){ board[y][x]=null; cleared++; }
    }
    return {cleared, interior};
  }

  function updateHUD(){
    scoreEl.textContent=score;
    bestEl.textContent=best;
  }


  function anyMoveAvailable(){
    for(const p of pieces){
      if(p.used) continue;
      for(let y=0;y<GRID;y++){
        for(let x=0;x<GRID;x++){
          if(canPlace(p,x,y)) return true;
        }
      }
    }
    return false;
  }

  const banner=document.getElementById("banner");
  const bannerTitle=document.getElementById("bannerTitle");
  const bannerText=document.getElementById("bannerText");
  const restartBtn=document.getElementById("restartBtn");
  let gameOver=false;

  function setGameOver(on){
    gameOver=!!on;
    if(banner) banner.style.display = on ? "block" : "none";
  }


  function renderPieces(){
    piecesEl.innerHTML="";
    pieces.forEach((p,idx)=>{
      const slot=document.createElement("div");
      slot.className="slot"+(p.used?" used":"");
      const mini=document.createElement("canvas");
      mini.className="mini";
      mini.width=160; mini.height=90;
      slot.appendChild(mini);

      const m=mini.getContext("2d");
      const block=16, gap=5;
      const w=p.w*block+(p.w-1)*gap, h=p.h*block+(p.h-1)*gap;
      const ox=(mini.width-w)/2, oy=(mini.height-h)/2;
      for(let y=0;y<p.h;y++) for(let x=0;x<p.w;x++){
        if(!p.shape[y][x]) continue;
        rr(m, ox+x*(block+gap), oy+y*(block+gap), block, block, 6);
        m.fillStyle=p.color; m.fill();
      }

      const label=document.createElement("div");
      label.className="slotLabel";
      label.textContent = `${p.w}Ã—${p.h}`;
      slot.appendChild(label);

      slot.addEventListener("pointerdown",(e)=>{
        if(p.used) return;
        canvas.setPointerCapture(e.pointerId);
        const pt=clientToCanvas(e.clientX,e.clientY);
        dragging={piece:p, idx, x:pt.x, y:pt.y};
        hoverCell=pointerToGrid(e.clientX,e.clientY);
      });

      piecesEl.appendChild(slot);
    });
  }

  canvas.addEventListener("pointermove",(e)=>{
    if(!dragging) return;
    const pt=clientToCanvas(e.clientX,e.clientY);
    dragging.x=pt.x; dragging.y=pt.y;
    hoverCell=pointerToGrid(e.clientX,e.clientY);
  });

  canvas.addEventListener("pointerup",(e)=>{
    if(gameOver) return;
    if(!dragging) return;
    const p=dragging.piece;
    const drop=pointerToGrid(e.clientX,e.clientY);
    if(!drop || !canPlace(p,drop.x,drop.y)){
      dragging=null; hoverCell=null; return;
    }

    const effective = placePiece(p, drop.x, drop.y);
    p.used=true;

    score += effective*6;
    tickBlackSeedsFlagged();

    const cap=capture();
    if(cap.cleared>0){
      const pts = Math.round(cap.cleared*26 + cap.interior*3);
      score += pts;
    }

    if(pieces.every(pp=>pp.used)) rollPieces(); else renderPieces();

    if(score>best){best=score; localStorage.setItem("echo_grid_best_minimal", String(best));}
    updateHUD();

    // game over check
    if(!anyMoveAvailable()){
      setGameOver(true);
    }

    dragging=null; hoverCell=null;
  });

  canvas.addEventListener("lostpointercapture",()=>{dragging=null; hoverCell=null;});

  if(restartBtn){ restartBtn.addEventListener("click", ()=>{ newGame(); }); }

  function seed(){
    const seed=4+Math.floor(Math.random()*4);
    for(let i=0;i<seed;i++){
      const x=Math.floor(Math.random()*GRID), y=Math.floor(Math.random()*GRID);
      if(isEmpty(board[y][x])) board[y][x]={t:'c', color: COLORS[Math.floor(Math.random()*COLORS.length)]};
    }
    let placed=0, tries=0;
    while(placed<GRAY_COUNT && tries<1000){
      tries++;
      const x=Math.floor(Math.random()*GRID), y=Math.floor(Math.random()*GRID);
      if(isEmpty(board[y][x])){ board[y][x]={t:'g', uses: GRAY_START_USES}; placed++; }
    }
  }

  function drawPieceGhost(p,gx,gy,ok){
    const s=cellSize();
    for(let y=0;y<p.h;y++) for(let x=0;x<p.w;x++){
      if(!p.shape[y][x]) continue;
      const bx=gx+x, by=gy+y;
      if(bx<0||by<0||bx>=GRID||by>=GRID) continue;
      const {px,py}=cellToPx(bx,by);
      rr(ctx, px+2,py+2,s-4,s-4,10);
      ctx.fillStyle=hexToRgba(p.color, ok?0.25:0.10);
      ctx.fill();
      if(ok){
        rr(ctx, px+2,py+2,s-4,s-4,10);
        ctx.strokeStyle="rgba(255,255,255,.22)";
        ctx.lineWidth=2;
        ctx.stroke();
      }
    }
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const s=cellSize();

    for(let y=0;y<GRID;y++) for(let x=0;x<GRID;x++){
      const {px,py}=cellToPx(x,y);
      rr(ctx, px,py,s,s,12);
      ctx.fillStyle="rgba(27,39,64,.62)"; ctx.fill();
      ctx.strokeStyle="rgba(255,255,255,.14)"; ctx.lineWidth=1; ctx.stroke();

      const v=board[y][x];
      if(!v) continue;

      rr(ctx, px+1.2,py+1.2,s-2.4,s-2.4,11);

      if(isColor(v)){
        ctx.fillStyle=v.color; ctx.fill();
      } else if(isGray(v)){
        ctx.fillStyle="rgba(170,180,200,.75)"; ctx.fill();
        ctx.fillStyle="rgba(10,14,22,.85)";
        ctx.font=`900 ${Math.floor(s*0.38)}px system-ui`;
        ctx.textAlign="center"; ctx.textBaseline="middle";
        ctx.fillText(String(v.uses), px+s/2, py+s/2);
      } else if(isBlack(v)){
        ctx.fillStyle="rgba(12,12,14,.92)"; ctx.fill();
        ctx.fillStyle="rgba(255,255,255,.78)";
        ctx.font=`900 ${Math.floor(s*0.36)}px system-ui`;
        ctx.textAlign="center"; ctx.textBaseline="middle";
        ctx.fillText(String(v.ttl), px+s/2, py+s/2);
      } else if(isWall(v)){
        ctx.fillStyle="rgba(0,0,0,.96)"; ctx.fill();
        rr(ctx, px+1.2,py+1.2,s-2.4,s-2.4,11);
        ctx.strokeStyle="rgba(255,255,255,.10)";
        ctx.lineWidth=2; ctx.stroke();
      }
    }

    if(dragging && hoverCell){
      const p=dragging.piece;
      const ok=canPlace(p,hoverCell.x,hoverCell.y);
      drawPieceGhost(p,hoverCell.x,hoverCell.y,ok);
    }

    if(dragging){
      const p=dragging.piece;
      const px=dragging.x, py=dragging.y;
      const block=Math.min(30, s*0.62);
      const gap=4;
      const w=p.w*block+(p.w-1)*gap, h=p.h*block+(p.h-1)*gap;
      const ox=px-w/2, oy=py-h/2;
      for(let y=0;y<p.h;y++) for(let x=0;x<p.w;x++){
        if(!p.shape[y][x]) continue;
        rr(ctx, ox+x*(block+gap), oy+y*(block+gap), block, block, 8);
        ctx.fillStyle=p.color; ctx.fill();
        ctx.strokeStyle="rgba(255,255,255,.10)"; ctx.lineWidth=1; ctx.stroke();
      }
    }
  }

  function tick(){
    try{
      draw();
      errEl.style.display="none";
    }catch(e){
      errEl.style.display="block";
      errEl.textContent = (e && e.stack) ? e.stack : String(e);
    }
    requestAnimationFrame(tick);
  }

  function newGame(){
    setGameOver(false);
    board=emptyBoard();
    score=0;
    seed();
    rollPieces();
    updateHUD();
    // If somehow no moves from the start, re-roll a few times.
    for(let i=0;i<5 && !anyMoveAvailable();i++) rollPieces();
    if(!anyMoveAvailable()) setGameOver(true);
  }

  best = Number(localStorage.getItem("echo_grid_best_minimal")||"0") || 0;
  newGame();
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
